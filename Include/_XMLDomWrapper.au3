#include-once
; #INDEX# ======================================================================
; Title .........: _XMLDomWrapper
; AutoIt Version : 3.2.3++
; Language ......: English
; Description ...: Functions to use for reading and writing XML using msxml.
; Author ........: Stephen Podhajecki Eltorro
; ==============================================================================
; XML DOM Wrapper functions

#cs defs to add to au3.api
	_XMLCreateFile           Creates an XML file with the given name and root.
	_XMLFileOpen             Creates an instance of an XML file.
	_XMLSaveDoc              Save the xml doc,  use $iForce = 1 to force save if AutoSave is off.  
	; ==========================================================================
	_XMLGetChildNodes        Selects XML child Node(s) of an element based on XPath input from root node. 
	_XMLGetNodeCount         Get node count for specified path and type. 
	_XMLGetPath              Returns a nodes full path based on XPath input from root node. 
	; ==========================================================================
	_XMLSelectNodes          Selects XML Node(s) based on XPath input from root node. 
	_XMLGetField             Get XML Field(s) based on XPath input from root node.
	_XMLGetValue             Get XML Field based on XPath input from root node. 
	_XMLGetChildText         Selects XML child Node(s) of an element based on XPath input from root node. 
	_XMLUpdateField          Update existing node(s) based on XPath specs.
	_XMLReplaceChild         Replaces a node with a new node. 
	; ==========================================================================
	_XMLDeleteNode           Delete specified XPath node.
	_XMLDeleteAttr           Delete attribute for specified XPath
	_XMLDeleteAttrNode       Delete attribute node for specified XPath
	; ==========================================================================
	_XMLGetAttrib            Get XML attribute based on XPath input from root node.
	_XMLGetAllAttrib         Get all XML Field(s) attributes based on XPath input from root node.
	_XMLGetAllAttribIndex    Get all XML Field(s) attributes based on Xpathn and specific index.
	_XMLSetAttrib            Set XML Field(s) attributes based on XPath input from root node.
	; ==========================================================================
	_XMLCreateCDATA          Create a CDATA SECTION node directly under root. 
	_XMLCreateComment        Create a COMMENT node at specified path.
	_XMLCreateAttrib         Creates an attribute for the specified node. 
	; ==========================================================================
	_XMLCreateRootChild      Create node directly under root.
	_XMLCreateRootNodeWAttr  Create a child node under root node with attributes.
	_XMLCreateChildNode      Create a child node under the specified XPath Node.
	_XMLCreateChildWAttr     Create a child node under the specified XPath Node with Attributes. 
	; ==========================================================================
	_XMLSchemaValidate       Validate a document against a DTD. 
	_XMLGetDomVersion        Returns the XSXML version currently in use. 
	_XMLError                Sets or Gets XML error message generated by XML functions.
	_XMLUDFVersion           Returns the UDF Version number. 
	_XMLTransform            Transfroms the document using built-in sheet or xsl file passed to function. 
	_XMLNodeExists           Checks for the existence of the specified path. 
	; ==========================================================================
	_XMLSetAutoFormat        Turn auto indenting on or off.
	_XMLSetAutoSave          Set the automatic save to on or off.
#ce

; #VARIABLES# ==================================================================
Global Const $_XMLUDFVER = "1.0.3.97"
Global Const $NODE_ELEMENT = 1
Global Const $NODE_ATTRIBUTE = 2
Global Const $NODE_TEXT = 3
Global Const $NODE_CDATA_SECTION = 4
Global Const $NODE_ENTITY_REFERENCE = 5
Global Const $NODE_ENTITY = 6
Global Const $NODE_PROCESSING_INSTRUCTION = 7
Global Const $NODE_COMMENT = 8
Global Const $NODE_DOCUMENT = 9
Global Const $NODE_DOCUMENT_TYPE = 10
Global Const $NODE_DOCUMENT_FRAGMENT = 11
Global Const $NODE_NOTATION = 12
Global $strFile
Global $oXMLMyError ;COM error handler OBJ ; Initialize SvenP 's error handler
Global $sXML_error
Global $DOMVERSION = -1
Global $objDoc
Global $fXMLAUTOSAVE = True ;auto save updates
Global $fADDFORMATTING = True ;auto indent
; ==============================================================================

; #FUNCTION# ===================================================================
; Name ..........: _XMLFileOpen
; Description ...: Creates an instance of an XML file.
; Syntax.........:  _XMLFileOpen($strXMLFile[, $strNameSpc = ""[, $iVer = -1[, $fValOnParse = True]]])
; Parameters ....: $strXMLFile    - the XML file to open
;                  $strNameSpc    - the namespace to specifiy if the file uses one.
;                  $iVer          - specifically try to use the version supplied here.
;                  $fValOnParse   - validate the document as it is being parsed
; Return values .: Success        - 1
;                  Failure        - -1 and set @error to:
;                  |0 - No error
;                  |1 - Parse error, @Extended = MSXML reason
;                  |2 - No object
; Author ........: Stephen Podhajecki <gehossafats@netmdc.com>
; Modified ......:
; Remarks .......:
; Related .......:
; Link ..........;
; Example .......; [yes/no]
; ==============================================================================
Func _XMLFileOpen($strXMLFile, $strNameSpc = "", $iVer = -1, $fValOnParse = True)
	;==== pick your poison
	If $iVer <> -1 Then
		If $iVer > -1 And $iVer < 7 Then
			$objDoc = ObjCreate("Msxml2.DOMDocument." & $iVer & ".0")
			If IsObj($objDoc) Then
				$DOMVERSION = $iVer
			EndIf
		Else
			MsgBox(266288, "Error:", "Failed to create object with MSXML version " & $iVer)
			SetError(1)
			Return 0
		EndIf
	Else
		For $x = 8 To 0 Step -1
			If FileExists(@SystemDir & "\msxml" & $x & ".dll") Then
				$objDoc = ObjCreate("Msxml2.DOMDocument." & $x & ".0")
				If IsObj($objDoc) Then
					$DOMVERSION = $x
					ExitLoop
				EndIf
			EndIf
		Next
	EndIf
	If Not IsObj($objDoc) Then
		_XMLError("Error: MSXML not found. This object is required to use this program.")
		SetError(2)
		Return -1
	EndIf
	;Thanks Lukasz Suleja
	$oXMLMyError = ObjEvent("AutoIt.Error")
	If $oXMLMyError = "" Then
		$oXMLMyError = ObjEvent("AutoIt.Error", "_XMLCOMEerr") ; ; Initialize SvenP 's error handler
	EndIf
	$strFile = $strXMLFile
	$objDoc.async = False
	$objDoc.preserveWhiteSpace = True
	$objDoc.validateOnParse = $fValOnParse
	If $DOMVERSION > 4 Then $objDoc.setProperty("ProhibitDTD", False)
	$objDoc.Load($strFile)
	$objDoc.setProperty("SelectionLanguage", "XPath")
	$objDoc.setProperty("SelectionNamespaces", $strNameSpc)
	If $objDoc.parseError.errorCode > 0 Then ConsoleWrite($objDoc.parseError.reason & @LF)
	If $objDoc.parseError.errorCode <> 0 Then
		_XMLError("Error opening specified file: " & $strXMLFile & @CRLF & $objDoc.parseError.reason)
		;Tom Hohmann 2008/02/29
		SetError(1, $objDoc.parseError.errorCode, -1)
		$objDoc = 0
		Return -1
	EndIf
	;Tom Hohmann 2008/02/29
	Return 1
EndFunc   ;==>_XMLFileOpen

; #FUNCTION# ===================================================================
; Name ..........: _XMLDeleteNode
; Description ...: Deletes XML Node based on XPath input from root node.
; Syntax.........:  _XMLDeleteNode($strXPath)
; Parameters ....: $strXPath      - The XML tree path from root node (root/child/child..)
; Return values .: Success        - 1
;                  Failure        - -1 and sets @Error to:
;                  |0 - No error
;                  |1 - Deletion error
;                  |2 - No object passed
; Author ........: Stephen Podhajecki <gehossafats@netmdc.com>
; Modified ......:
; Remarks .......:
; Related .......:
; Link ..........;
; Example .......; [yes/no]
; ==============================================================================
Func _XMLDeleteNode($strXPath)
	If Not IsObj($objDoc) Then
		_XMLError("No object passed to function _XMLDeleteNode")
		Return SetError(2, 0, -1)
	EndIf
	Local $objNode, $xmlerr
	$objNode = $objDoc.selectNodes($strXPath)
	If Not IsObj($objNode) Then $xmlerr = @CRLF & "Node Not found"
	If @error = 0 Then
		For $objChild In $objNode
			If $objChild.hasChildNodes Then
				For $objGrandChild in $objChild.childNodes
					If $objGrandChild.nodeType = $NODE_TEXT Then
						If StringStripWS($objGrandChild.text,7) = "" Then
							$objChild.removeChild($objGrandChild)
						EndIf
					EndIf
				Next
			EndIf
			$objChild.parentNode.removeChild($objChild)
		Next
		_XMLSaveDoc($strFile)
		Return 1
	EndIf
	_XMLError("Error Deleting Node: " & $strXPath & $xmlerr)
	Return SetError(1, 0, -1)
EndFunc   ;==>_XMLDeleteNode

; #FUNCTION# ===================================================================
; Name ..........: _XMLGetAttrib
; Description ...: Get XML Field based on XPath input from root node.
; Syntax.........:  _XMLGetAttrib($strXPath, $strAttrib[, $strQuery = ""])
; Parameters ....: $strXPath      - XML tree path from root node (root/child/child..)
;                  $strAttrib     - The attribute node to read.
;                  $strQuery      - The query string in xml format
; Return values .: Success        - The attribute value.
;                  Failure        - -1 and sets	@Error to:
;                  |0 - No error
;                  |1 - Attribute not found.
;                  |2 - No object
; Author ........: Stephen Podhajecki <gehossafats@netmdc.com>
; Modified ......:
; Remarks .......:
; Related .......:
; Link ..........;
; Example .......; [yes/no]
; ==============================================================================
Func _XMLGetAttrib($strXPath, $strAttrib, $strQuery = "")
	If Not IsObj($objDoc) Then
		_XMLError("No object passed to function _XMLGetAttrib")
		Return SetError(2, 0, -1)
	EndIf
	;Local $objNodeList, $arrResponse[1], $i, $xmlerr, $objAttr
	Local $objNodeList, $arrResponse, $i, $xmlerr, $objAttr
	$objNodeList = $objDoc.documentElement.selectNodes($strXPath & $strQuery)
	If $objNodeList.length > 0 Then
		For $i = 0 To $objNodeList.length - 1
			$objAttr = $objNodeList.item($i).getAttribute($strAttrib)
			$arrResponse = $objAttr
		Next
		Return $arrResponse
	EndIf
	$xmlerr = "\nNo qualified items found"
	_XMLError("Attribute " & $strAttrib & " not found for: " & $strXPath & $xmlerr)
	Return SetError(1, 0, -1)
EndFunc   ;==>_XMLGetAttrib

; #FUNCTION# ===================================================================
; Name ..........: _XMLCreateAttribute
; Description ...: Adds an XML Attribute to specified node.
; Syntax.........:  _XMLCreateAttrib($strXPath, $strAttrName[, $strAttrValue = ""])
; Parameters ....: $strXPath      - The XML tree path from root node (root/child/child..)
;                  $strAttrName   - The attribute to set.
;                  $strAttrValue  - The value to give the attribute, defaults to "".
; Return values .: Success        - 1
;                  Failure        - 0 or @error set to 0 and return -1
; Author ........: Stephen Podhajecki <gehossafats@netmdc.com>
; Modified ......:
; Remarks .......:
; Related .......:
; Link ..........;
; Example .......; [yes/no]
; ==============================================================================
Func _XMLCreateAttrib($strXPath, $strAttrName, $strAttrValue = "")
	If Not IsObj($objDoc) Then
		_XMLError("No object passed to function _XMLCreateAttrib")
		Return SetError(1, 12, -1)
	EndIf
	Local $objNode, $objAttr, $objAttrVal, $err
	$objNode = $objDoc.selectSingleNode($strXPath)
	If IsObj($objNode) Then
		$objAttr = $objDoc.createAttribute($strAttrName);, $strNameSpc)
		$objNode.SetAttribute($strAttrName, $strAttrValue)
		_XMLSaveDoc($strFile)
		$objAttr = 0
		$objAttrVal = 0
		$objNode = 0
		$err = $objDoc.parseError.errorCode
		If $err = 0 Then Return 1
	EndIf
	_XMLError("Error creating Attribute: " & $strAttrName & @CRLF & $strXPath & " does not exist." & @CRLF)
	Return 0
EndFunc   ;==>_XMLCreateAttrib

; #FUNCTION# ===================================================================
; Name ..........: _XMLCreateChildNode
; Description ...: Create a child node under the specified XPath Node.
; Syntax.........:  _XMLCreateChildNode($strXPath, $strNode[, $strData = ""[, $strNameSpc = ""]])
; Parameters ....: $strXPath      - The node from root.
;                  $strNode       - Node name to add.
;                  $strData       - Value to give the node
; Return values .: Success        - 1
;                  Failure        - -1 and @error set to 1.
; Author ........: Stephen Podhajecki <gehossafats@netmdc.com>
; Modified ......:
; Remarks .......:
; Related .......:
; Link ..........;
; Example .......; [yes/no]
; ==============================================================================
Func _XMLCreateChildNode($strXPath, $strNode, $strData = "", $strNameSpc = "")
	If Not IsObj($objDoc) Then
		_XMLError("No object passed to function _XMLCreateChildNode")
		Return SetError(1, 16, -1)
	EndIf
	Local $objParent, $objChild, $objNodeList
	$objNodeList = $objDoc.selectNodes($strXPath)
	If IsObj($objNodeList) And $objNodeList.length > 0 Then
		For $objParent In $objNodeList
			If Not ($objParent.hasChildNodes()) Then
				_AddFormat($objDoc, $objParent)
			EndIf
			If $strNameSpc = "" Then
				If Not ($objParent.namespaceURI = 0 Or $objParent.namespaceURI = "") Then $strNameSpc = $objParent.namespaceURI
			EndIf
			;ConsoleWrite("$strNameSpc=" & $strNameSpc & @LF)
			$objChild = $objDoc.createNode($NODE_ELEMENT, $strNode, $strNameSpc)
			If $strData <> "" Then $objChild.text = $strData
			$objParent.appendChild($objChild)
			_AddFormat($objDoc, $objParent)
		Next
		_XMLSaveDoc($strFile)
		$objParent = ""
		$objChild = ""
		Return 1
	EndIf
	_XMLError("Error creating child node: " & $strNode & @CRLF & $strXPath & " does not exist." & @CRLF)
	Return SetError(1, 0, -1)
EndFunc   ;==>_XMLCreateChildNode

; #FUNCTION# ===================================================================
; Name ..........: _XMLCreateChildWAttr
; Description ...: Create a child node(s) under the specified XPath Node with attributes.
; Syntax.........:  _XMLCreateChildWAttr($strXPath, $strNode, $aAttr, $aVal[, $strData = ""[, $strNameSpc = ""]])
; Parameters ....: $sPath         - Path from root
;                  $sNode         - The node to add with attibute(s)
;                  $aAttr         - The attribute name(s) -- can be array
;                  $aVal          - The	attribute value(s) -- can be array
;                  $strData       - The optional value to give the child node.
; Return values .: Success        - 1
;                  Failure        - -1, @error set to:
;                  |1 - Could not create node.
;                  |2 - Mismatch between attribute name and value counts.
;                  |3 - Attribute Name cannot be empty string.
; Author ........: Stephen Podhajecki <gehossafats@netmdc.com>
; Modified ......:
; Remarks .......: This function requires that each attribute name has	a corresponding value.
; Related .......:
; Link ..........;
; Example .......; [yes/no]
; ==============================================================================
Func _XMLCreateChildWAttr($strXPath, $strNode, $aAttr, $aVal, $strData = "", $strNameSpc = "")
	If Not IsObj($objDoc) Then
		_XMLError("No object passed to function _XMLCreateChildWAttr")
		Return SetError(1, 18, -1)
	EndIf
	Local $objParent, $objChild, $objAttr, $objAttrVal, $objNodeList
	$objNodeList = $objDoc.selectNodes($strXPath)
	If IsObj($objNodeList) And $objNodeList.length <> 0 Then
		For $objParent In $objNodeList
			If Not ($objParent.hasChildNodes()) Then
				_AddFormat($objDoc, $objParent)
			EndIf
			If $strNameSpc = "" Then
				If Not ($objParent.namespaceURI = 0 Or $objParent.namespaceURI = "") Then $strNameSpc = $objParent.namespaceURI
			EndIf
			$objChild = $objDoc.createNode($NODE_ELEMENT, $strNode, $strNameSpc)
			If @error Then Return -1
			If $strData <> "" Then $objChild.text = $strData
			If IsArray($aAttr) And IsArray($aVal) Then
				If UBound($aAttr) <> UBound($aVal) Then
					_XMLError("Attribute and value mismatch" & @CRLF & "Please make sure each attribute has a matching value.")
					Return SetError(2, 0, -1)
				Else
					Local $i
					For $i = 0 To UBound($aAttr) - 1
						If $aAttr[$i] = "" Then
							_XMLError("Error creating child node: " & $strNode & @CRLF & " Attribute Name Cannot be NULL." & @CRLF)
							Return SetError(1, 0, -1)
						EndIf
						$objAttr = $objDoc.createAttribute($aAttr[$i]);, $strNameSpc)
						If @error Then ExitLoop
						$objChild.SetAttribute($aAttr[$i], $aVal[$i])
						If @error <> 0 Then
							_XMLError("Error creating child node: " & $strNode & @CRLF & $strXPath & " does not exist." & @CRLF)
							Return SetError(1, 0, -1)
						EndIf
					Next
				EndIf
			Else
				If IsArray($aAttr) Or IsArray($aVal) Then
					_XMLError("Type non-Array and Array detected" & @LF)
					Return SetError(1, 0, -1)
				EndIf
				If $aAttr = "" Then
					_XMLError("Attribute Name cannot be empty string." & @LF)
					Return SetError(3, 0, -1)
				EndIf
				$objAttr = $objDoc.createAttribute($aAttr);, $strNameSpc)
				$objChild.SetAttribute($aAttr, $aVal)
			EndIf
			$objParent.appendChild($objChild)
		Next
		_AddFormat($objDoc, $objParent)
		_XMLSaveDoc($strFile)
		$objParent = ""
		$objChild = ""
		Return 1
	EndIf
	_XMLError("Error creating child node: " & $strNode & @CRLF & $strXPath & " does not exist." & @CRLF)
	Return SetError(1, 0, -1)
EndFunc   ;==>_XMLCreateChildWAttr

; #FUNCTION# ===================================================================
; Name ..........: _XMLGetNodeCount
; Description ...: Get Node Count based on XPath input from root node.
; Syntax.........:  _XMLGetNodeCount($strXPath[, $strQry = ""[, $iNodeType = 1]])
; Parameters ....: $strXPath      - The XML tree path from root node (root/child/child..
;                  $strQry        - A DOM compliant query string (not really necessary as it becomes part of the path
;                  $iNodeType     - The type of node to count. (element, attrib, comment etc.)
; Return values .: Success        - Number of nodes found (can be 0)
;                  Failure        - -1 and @error set to 1.
; Author ........: Stephen Podhajecki <gehossafats@netmdc.com> & DickB
; Modified ......:
; Remarks .......:
; Related .......:
; Link ..........;
; Example .......; [yes/no]
; ==============================================================================
Func _XMLGetNodeCount($strXPath, $strQry = "", $iNodeType = 1)
	If Not IsObj($objDoc) Then
		_XMLError("No object passed to function _XMLGetNodeCount")
		Return SetError(1, 22, -1)
	EndIf
	Local $objQueryNodes, $objNode, $nodeCount = 0, $errMsg
	$objQueryNodes = $objDoc.selectNodes($strXPath & $strQry)
	If @error = 0 And $objQueryNodes.length > 0 Then
		For $objNode In $objQueryNodes
			If $objNode.nodeType = $iNodeType Then $nodeCount = $nodeCount + 1
		Next
		Return $nodeCount
	Else
		$errMsg = "No nodes of specified type found."
	EndIf
	_XMLError("Error retrieving node count for: " & $strXPath & @CRLF & $errMsg & @CRLF)
	SetError(1)
	Return -1
	; EndIf
EndFunc   ;==>_XMLGetNodeCount

; #FUNCTION# ===================================================================
; Name ..........: _XMLError
; Description ...: Sets or Gets error message that may be generated by the UDF functs.
; Syntax.........:  _XMLError($sError = "")
; Parameters ....: $sError        - Error message to set.
; Return values .: Success        - one of the following:
;                  |$sError <> "" - Nothing.
;                  |$sError = "" - Last error set.
;                  Failure        - Nothing.
; Author ........: Stephen Podhajecki <gehossafats@netmdc.com>
; Modified ......:
; Remarks .......:
; Related .......:
; Link ..........;
; Example .......; [yes/no]
; ==============================================================================
Func _XMLError($sError = "")
	If $sError = "" Then
		$sError = $sXML_error
		$sXML_error = ""
		Return $sError
	Else
		$sXML_error = StringFormat($sError)
	EndIf
EndFunc   ;==>_XMLError

; #FUNCTION# ===================================================================
; Name ..........: _XMLTransform
; Description ...:
; Syntax.........:  _XMLTransform([$oXMLDoc = ""[, $Style = ""[, $szNewDoc = ""]]])
; Parameters ....: $oXMLDoc       - The document to transform
;                  $Style         - The stylesheet to use
;                  $szNewDoc      - Save to this file.
; Return values .: Success        - Returns True
;                  Failure        - -1 and @error set to 1.
; Author ........: Stephen Podhajecki <gehossafats at netmdc dot com>, Modified by WeaponX
; Modified ......:
; Remarks .......: Default stylesheet is used for indenting.
; Related .......:
; Link ..........;
; Example .......; [yes/no]
; ==============================================================================
Func _XMLTransform($oXMLDoc = "", $Style = "", $szNewDoc = "")
	If $oXMLDoc = "" Then
		$oXMLDoc = $objDoc
	EndIf
	If Not IsObj($oXMLDoc) Then
		_XMLError("No object passed to function _XMLTransform")
		Return SetError(1, 29, -1)
	EndIf
	Local $fIndented = False
	Local $xslt = ObjCreate("MSXML2.XSLTemplate." & $DOMVERSION & ".0")
	Local $xslDoc = ObjCreate("MSXML2.FreeThreadedDOMDocument." & $DOMVERSION & ".0")
	Local $xmldoc = ObjCreate("MSXML2.DOMDocument." & $DOMVERSION & ".0")
	Local $xslProc
	$xslDoc.async = False
	If FileExists($Style) Then
		$xslDoc.load($Style)
	Else
		$xslDoc.loadXML(_GetDefaultStyleSheet())
	EndIf
	If $xslDoc.parseError.errorCode <> 0 Then
		_XMLError("Error Transforming NodeToObject: " & $xslDoc.parseError.reason)
	EndIf
	
	$xslt.stylesheet = $xslDoc
	$xslProc = $xslt.createProcessor()
	$xslProc.input = $objDoc
	$oXMLDoc.transformNodeToObject($xslDoc, $xmldoc)
	If $oXMLDoc.parseError.errorCode <> 0 Then
		_XMLError("_XMLTransform:" & @LF & "Error Transforming NodeToObject: " & $oXMLDoc.parseError.reason)
		$fIndented = False
	Else
		$fIndented = True
	EndIf
	If $fIndented Then
		;Write transformed xml to a file if a filename is given
		If $szNewDoc <> "" Then
			$xmldoc.save($szNewDoc)
			If $xmldoc.parseError.errorCode <> 0 Then
				_XMLError("_XMLTransform:" & @LF & "Error Saving: " & $xmldoc.parseError.reason)
				$fIndented = False
			EndIf
		Else
			;Overwrite original object with transformed object
			$objDoc = $xmldoc
			_XMLSaveDoc($strFile)
			If $oXMLDoc.parseError.errorCode <> 0 Then
				_XMLError("_XMLTransform:" & @LF & "Error Saving: " & $oXMLDoc.parseError.reason)
				$fIndented = False
			EndIf
		EndIf
	EndIf
	$xslProc = 0
	$xslt = 0
	$xslDoc = 0
	$xmldoc = 0
	If $fIndented = False Then Return SetError(1, 0, -1)
	Return $fIndented
EndFunc   ;==>_XMLTransform

; #INTERNAL_USE_ONLY#==========================================================
; Name ..........: _GetDefaultStyleSheet
; Description ...: Internal function, returns the default indenting style sheet.
; Syntax.........:  _GetDefaultStyleSheet()
; Parameters ....:
; Return values .: Success        - The default stylesheet.
;                  Failure        - Nothing.
; Author ........: Hew Wolff - Art & Logic, Inc.
; Modified ......:
; Remarks .......: Posted all over the web.
; Related .......:
; Link ..........;
; Example .......; [yes/no]
; ==============================================================================
Func _GetDefaultStyleSheet()

	Return '<?xml version="1.0" encoding="UTF-8"?>' & _
			'<!--' & _
			'Converts XML into a nice readable format.' & _
			'Tested with Saxon 6.5.3.' & _
			'As a test, this stylesheet should not change when run on itself.' & _
			'But note that there are no guarantees about attribute order within an' & _
			'element (see http://www.w3.org/TR/xpath#dt-document-order), or about' & _
			'which characters are escaped (see' & _
			'http://www.w3.org/TR/xslt#disable-output-escaping).' & _
			'I did not test processing instructions, CDATA sections, or' & _
			'namespaces.' & _
			'Hew Wolff' & _
			'Senior Engineer' & _
			'Art & Logic, Inc.' & _
			'www.artlogic.com' & _
			'-->' & _
			'<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">' & _
			'<!-- Take control of the whitespace. -->' & _
			'<xsl:output method="xml" indent="no" encoding="UTF-8"/>' & _
			'<xsl:strip-space elements="*"/>' & _
			'<xsl:preserve-space elements="xsl:text"/>' & _
			'<!-- Copy comments, and elements recursively. -->' & _
			'<xsl:template match="*|comment()">' & _
			'<xsl:param name="depth">0</xsl:param>' & _
			'<!--' & _
			'Set off from the element above if one of the two has children.' & _
			'Also, set off a comment from an element.' & _
			'And set off from the XML declaration if necessary.' & _
			'-->' & _
			'<xsl:variable name="isFirstNode" select="count(../..) = 0 and position() = 1"/>' & _
			'<xsl:variable name="previous" select="preceding-sibling::node()[1]"/>' & _
			'<xsl:variable name="adjacentComplexElement" select="count($previous/*) &gt; 0 or count(*) &gt; 0"/>' & _
			'<xsl:variable name="adjacentDifferentType" select="not(($previous/self::comment() and self::comment()) or ($previous/self::* and self::*))"/>' & _
			'<xsl:if test="$isFirstNode or ($previous and ($adjacentComplexElement or $adjacentDifferentType))">' & _
			'<xsl:text>&#xA;</xsl:text>' & _
			'</xsl:if>' & _
			'<!-- Start a new line.' & _
			'<xsl:text>&#xA;</xsl:text> -->' & _
			'<xsl:call-template name="indent">' & _
			'<xsl:with-param name="depth" select="$depth"/>' & _
			'</xsl:call-template>' & _
			'<xsl:copy>' & _
			'<xsl:if test="self::*">' & _
			'<xsl:copy-of select="@*"/>' & _
			'<xsl:apply-templates>' & _
			'<xsl:with-param name="depth" select="$depth + 1"/>' & _
			'</xsl:apply-templates>' & _
			'<xsl:if test="count(*) &gt; 0">' & _
			'<xsl:text>&#xA;</xsl:text>' & _
			'<xsl:call-template name="indent">' & _
			'<xsl:with-param name="depth" select="$depth"/>' & _
			'</xsl:call-template>' & _
			'</xsl:if>' & _
			'</xsl:if>' & _
			'</xsl:copy>' & _
			'<xsl:variable name="isLastNode" select="count(../..) = 0 and position() = last()"/>' & _
			'<xsl:if test="$isLastNode">' & _
			'<xsl:text>&#xA;</xsl:text>' & _
			'</xsl:if>' & _
			'</xsl:template>' & _
			'<xsl:template name="indent">' & _
			'<xsl:param name="depth"/>' & _
			'<xsl:if test="$depth &gt; 0">' & _
			'<xsl:text>   </xsl:text>' & _
			'<xsl:call-template name="indent">' & _
			'<xsl:with-param name="depth" select="$depth - 1"/>' & _
			'</xsl:call-template>' & _
			'</xsl:if>' & _
			'</xsl:template>' & _
			'<!-- Escape newlines within text nodes, for readability. -->' & _
			'<xsl:template match="text()">' & _
			'<xsl:call-template name="escapeNewlines">' & _
			'<xsl:with-param name="text">' & _
			'<xsl:value-of select="."/>' & _
			'</xsl:with-param>' & _
			'</xsl:call-template>' & _
			'</xsl:template>' & _
			'<xsl:template name="escapeNewlines">' & _
			'<xsl:param name="text"/>' & _
			'<xsl:if test="string-length($text) &gt; 0">' & _
			'<xsl:choose>' & _
			'<xsl:when test="substring($text, 1, 1) = ' & "'#xA;'" & '">' & _
			'<xsl:text disable-output-escaping="yes">&amp;#xA;</xsl:text>' & _
			'</xsl:when>' & _
			'<xsl:otherwise>' & _
			'<xsl:value-of select="substring($text, 1, 1)"/>' & _
			'</xsl:otherwise>' & _
			'</xsl:choose>' & _
			'<xsl:call-template name="escapeNewlines">' & _
			'<xsl:with-param name="text" select="substring($text, 2)"/>' & _
			'</xsl:call-template>' & _
			'</xsl:if>' & _
			'</xsl:template>' & _
			'</xsl:stylesheet>'
EndFunc   ;==>_GetDefaultStyleSheet

; #INTERNAL_USE_ONLY#==========================================================
; Name ..........: _AddFormat
; Description ...:
; Syntax.........:  _AddFormat($objDoc[, $objParent = ""])
; Parameters ....: $objDoc	       - Document to format
;                  $objParent     - Optional node to add formatting to
; Return values .: Success        - 1
;                  Failure        - -1 and @error set to 1.
; Author ........: Stephen Podhajecki <gehossafats a t netmdc.com>
; Modified ......:
; Remarks .......: Just break up the tags, no indenting is done here.
; Related .......:
; Link ..........;
; Example .......; [yes/no]
; ==============================================================================
Func _AddFormat($objDoc, $objParent = "")
	If $fADDFORMATTING = True Then
		If Not IsObj($objDoc) Then
			_XMLError("No object passed to function _XMLAddFormat")
			Return SetError(1, 30, -1)
		EndIf
		Local $objFormat = $objDoc.createTextNode(@CR)
		If IsObj($objParent) Then
			$objParent.appendChild($objFormat)
		Else
			$objDoc.documentElement.appendChild($objFormat)
		EndIf
		_XMLSaveDoc($strFile)
	EndIf
	Return 1
EndFunc   ;==>_AddFormat

; #FUNCTION# ===================================================================
; Name ..........: _XMLSetAutoSave
; Description ...: Set the automatic save to on or off
; Syntax.........:  _XMLSetAutoSave($fSave = True)
; Parameters ....: $fSave         - Boolean value to set automatic saving.
; Return values .: Success        - Previous state of autosave.
; Author ........: Stephen Podhajecki <gehossafats a t netmdc.com>
; Modified ......:
; Remarks .......: Defaults to true.
; Related .......:
; Link ..........;
; Example .......; [yes/no]
; ==============================================================================
Func _XMLSetAutoSave($fSave = True)
	Local $oldSave = $fXMLAUTOSAVE
	$fXMLAUTOSAVE = $fSave
	Return $oldSave
EndFunc   ;==>_XMLSetAutoSave

; #FUNCTION# ===================================================================
; Name ..........: _XMLSetAutoFormat
; Description ...: Turn auto formatting on or off
; Syntax.........:  _XMLSetAutoFormat($fAutoFormat = True)
; Parameters ....: $fAutoFormat   - Boolean flag for automatic formatting
; Return values .: Success        - The previous state.
;                  Failure        - Nothing.
; Author ........: Stephen Podhajecki {gehossafats at netmdc. com}
; Modified ......:
; Remarks .......:
; Related .......:
; Link ..........;
; Example .......; [yes/no]
; ==============================================================================
Func _XMLSetAutoFormat($fAutoFormat = True)
	Local $oldFormat = $fADDFORMATTING
	$fADDFORMATTING = $fAutoFormat
	Return $oldFormat
EndFunc   ;==>_XMLSetAutoFormat

; #FUNCTION# ===================================================================
; Name ..........: _XMLSaveDoc
; Description ...: Save the current xml doc
; Syntax.........:  _XMLSaveDoc([$sFile=""[,$iForce = 0]])
; Parameters ....: $sFile         - The filename to save the xml doc as.
;                  $iForce        - If true, save the file regardless of autosave state.
; Return values .: Success        - 1
;                  Failure        - -1 and @error set to the following:
;                  |1 - error trying to save.
;                  |2 - Autosave is off.
;                  |3 - No filename given for save and default is blank.
; Author ........: Stephen Podhajecki {gehossafats at netmdc. com}
; Modified ......:
; Remarks .......: Defaults to the current filename.
; Related .......:
; Link ..........;
; Example .......; [yes/no]
; ==============================================================================
Func _XMLSaveDoc($sFile = "", $iForce = 0)
	If ($fXMLAUTOSAVE = True) Or ($iForce = 1) Then
		If $sFile = "" Then $sFile = $strFile
		If $sFile <> "" Then
			$objDoc.save($sFile)
			If $objDoc.parseError.errorCode <> 0 Then
				_XMLError("_XMLSaveDoc: Saving " & $sFile & " failed.:" & @LF & _
						$objDoc.parseError.errorCode & _
						" " & $objDoc.parseError.reason)
				Return SetError(1, 0, -1)
			EndIf
			Return 1
		Else
			_XMLError("_XMLSaveDoc:" & " Error Saving: No Filename given")
			Return SetError(3, 0, -1)
		EndIf
	EndIf
	Return SetError(2, 0, 1)
EndFunc   ;==>_XMLSaveDoc
